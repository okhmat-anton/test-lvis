<script>
  /*
   Start 5:55 PM 03/27/2023
   End 7:32 PM 03/27/2023
   */


  /*
      Task: Find the minimum number of sticks to get the number K. Its possible use one stick several times.
      Input: K, arraySticks
      Output: minimum number of cuts or -1 if impossible

      Solution Explanation:
      1. Check if possibles any errors in input data
      2. Check variants that can not be solved without recursion (K in arraySticks)
      3. Check can we divide K on any number in arraySticks - and setup maximum count of recursion
      4. Minus from K the biggest number in arraySticks in recursion till we have 0 or less
      and cut deep if we have count recursion > current of minCount (but only if we already have minCount > 0)
      5. Return result

      Solution not maybe optimal, but it's the first thing that came to mind

   */


  // global var for recursion
  let minCount = 0;

  // calculate minCount in recursion
  function getMinCountRecursion(K, arraySticks, count) {
    count++;
    // because we need to find min count, if count > maxCount - we can stop recursion with false
    if (minCount > 0 && count > minCount) {
      // console.log('STOP recursion ', count,'>', minCount);
      return -1;
    }

    for(let i=0; i<arraySticks.length; i++) {
      let newK = K - arraySticks[i];
      // console.log('L', count,' newK ==> ',  K+ '-'+ arraySticks[i]+ '='+ newK, 'minCount', minCount)
      if(newK === 0) { // if we found min count
        if(count < minCount || minCount < 1) {
          minCount = count;
          // console.log('find = ',minCount);
        }
        return;
      }
      if(newK < 0) { // not work for us
        // console.log('STOP BAD recursion newK < 0',newK, K, count, minCount);
        continue;
      }
      if(newK > 0) { // continue recursion

        // make copy of array
        let arraySticksCopy = arraySticks.slice();
        // delete from array all numbers > newK
        for (let j = 0; j < arraySticksCopy.length; j++) {
          if (arraySticksCopy[j] > newK) {
            arraySticksCopy.splice(j, 1);
            j--;
          }
        }
        getMinCountRecursion(newK, arraySticksCopy, count);
      }
    }
  }

  function getMinCountSticks(K, arraySticks) {
    minCount = 0; // reset global var
    // check if K < 1 || K>10000 - can't be
    if (K<1 || K>10000) {
      return -1;
    }
    // check if K is in array
    if (arraySticks.includes(K)) {
      return 1;
    }
    // delete from array all numbers > K or < 1
    for (let i = 0; i < arraySticks.length; i++) {
      if (arraySticks[i] > K || arraySticks[i] < 1) {
        arraySticks.splice(i, 1);
        i--;
      }
    }
    //sort array from max to min
    arraySticks.sort(function(a, b) {
      return b - a;
    });

    // check if its possible divide K by any number in array and save min count
    for (let i = 0; i < arraySticks.length; i++) {
      if (K % arraySticks[i] === 0) {
        minCount = K / arraySticks[i];
        break; // only biggest number, can be many variants that can divide K
      }
    }

    // calculate minCount in recursion
    getMinCountRecursion(K, arraySticks, 0);

    if (minCount > 0) {
      return minCount;
    }
    return -1;
  }


  let K = 13; // 1 <= K <= 1000
  let arraySticks = [1, 5, 12]; // 1 <= arraySticks[i] <= 100000 , count in array N

  console.log(getMinCountSticks(K, arraySticks));

  K = 68; // 1 <= K <= 1000
  arraySticks = [1, 14, 30, 17]; // 1 <= arraySticks[i] <= 100000 , count in array N

  console.log(getMinCountSticks(K, arraySticks));

  K = 109; // 1 <= K <= 1000
  arraySticks = [13, 17, 43, 100, 110, 120, -100]; // 1 <= arraySticks[i] <= 100000 , count in array N

  console.log(getMinCountSticks(K, arraySticks));

</script>